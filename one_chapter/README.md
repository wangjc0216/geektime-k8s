# 容器概念入门篇

## 05 | 白话容器基础（一）：从进程说开去

### 概念理解

容器技术的三个事实：
```
容器技术的兴起源于 PaaS 技术的普及；
Docker 公司发布的 Docker 项目具有里程碑式的意义；
Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。
```


很重要的一句话：

> 容器本身没有价值，有价值的是“容器编排”。

也因为如此，爆发了容器编排的战争，最后以kubernetes和CNCF社区的胜利为告终。

**在本章节主要来介绍容器技术的实现原理**

容器是一种沙盒技术，会提供两个能力：
> 1. 沙盒像集装箱一样，可以把你的应用装起来。应用与应用之间因为有了边界而不相互干扰
> 2. 被装进集装箱的应用，可以被方便的搬来搬去。

所以，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；
而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。

而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。

**对于 Docker 等大多数 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。**

### 实践操作

1.在本地起一个busybox容器：
```shell
docker run -it busybox /bin/bash
```
其中，**-it**参数告诉Docker项目在启动容器后，需要给我们分配一个文本输入/输出的环境，
也就是TTY，跟容器的标准输入相关联，这样我们就可以和Docker容器进行交互了。


2. 在容器中执行**ps**命令
```shell
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    8 root      0:00 ps
```
这个容器一共有两个进程在运行，也就意味着，前面执行的/bin/bash，和当前执行的ps，已经被Docker隔离在一个与宿主机完全
不相同的世界中了。

这种机制，其实就是对被隔离应用的进程做了手脚，使得进程只能看见重新计算过的进程编号，如PID=1。
**这种技术，就叫做Namesapce**。

3. linux系统中创建线程的系统调用

一般来说，linux创建线程的系统调用如下：
```
int pid = clone(main_function, stack_size, SIGCHLD, NULL);
```
也可以在调用时选择**CLONE_NEWPID**参数：
```shell
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
```
这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。

之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。

4. PID Namespace

除了PID Namespace以外，还有Mount、UTS、IPC、Network 和 User 这些 Namespace，
用来对各种不同的进程上下文进行“障眼法”操作。

**容器，就是一种特殊的进程而已。**

### 总结
下面图为虚拟机与容器的比对：
![img.png](img.png)

左图中，Hypervisor 是虚拟机最重要的部分，它通过硬件虚拟化功能，模拟出了一个操作系统的多个硬件，比如CPU，内存，IO设备等。
然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。

而有图中，则用一个名为 Docker Engine 的软件替换了 Hypervisor。这就是很多人说Docker项目称为"轻量级"虚拟化技术的原因。
他们是把虚拟机的概念套用到了容器上。

理解Namespace工作方式后就会知道，Dockerx项目帮助用户启动的，还是原来的进程，只不过在创建这些进程时，Docker为他们加了
各种各样的参数。

**这时，这些进程会觉得自己是各自Namespace的第1号进程，只能看到各自Mount Namespace里挂载的目录和文件，
只能访问到Network Namespace里的网络设备，就仿佛运行在一个个"容器"里面，与世隔绝。**

其实都是障眼法罢了。

